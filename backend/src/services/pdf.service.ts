import PDFDocument from 'pdfkit';
import { TaskWithCounts } from '../models/task.model';

export interface PdfGenerationData {
  organizationName: string;
  projectName: string;
  projectAddress?: string;
  generatedAt: string;
  generatedBy: string;
  filterSummary: string;
  tasks: TaskWithCounts[];
}

/**
 * Generate a protocol PDF and return it as a Buffer.
 * Structure: Cover page → task tables grouped by trade → summary stats.
 */
export async function generateProtocolPdf(data: PdfGenerationData): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ margin: 50, size: 'A4' });
      const chunks: Buffer[] = [];

      doc.on('data', (chunk: Buffer) => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // ── Cover page ──────────────────────────────────────────
      doc.fontSize(28).font('Helvetica-Bold')
        .text('Protocol Report', { align: 'center' });
      doc.moveDown(2);

      doc.fontSize(18).font('Helvetica')
        .text(data.organizationName, { align: 'center' });
      doc.moveDown(0.5);

      doc.fontSize(16)
        .text(data.projectName, { align: 'center' });
      doc.moveDown(0.5);

      if (data.projectAddress) {
        doc.fontSize(12).fillColor('#666')
          .text(data.projectAddress, { align: 'center' });
        doc.moveDown(0.5);
      }

      doc.fontSize(12).fillColor('#333')
        .text(`Generated: ${data.generatedAt}`, { align: 'center' });
      doc.text(`Generated by: ${data.generatedBy}`, { align: 'center' });
      doc.moveDown(1);

      if (data.filterSummary) {
        doc.fontSize(10).fillColor('#666')
          .text(`Filters: ${data.filterSummary}`, { align: 'center' });
      }

      // ── Task tables grouped by trade ────────────────────────
      const tasksByTrade = groupByTrade(data.tasks);
      const trades = Object.keys(tasksByTrade).sort();

      for (const trade of trades) {
        doc.addPage();
        const tradeTasks = tasksByTrade[trade];

        doc.fontSize(16).font('Helvetica-Bold').fillColor('#333')
          .text(trade || 'No Trade', { underline: true });
        doc.moveDown(0.5);

        // Table header
        const startX = 50;
        let y = doc.y;
        const colWidths = [30, 180, 70, 70, 140];
        const headers = ['#', 'Title', 'Status', 'Priority', 'Assigned To'];

        doc.fontSize(9).font('Helvetica-Bold').fillColor('#333');
        drawTableRow(doc, headers, startX, y, colWidths);
        y += 20;

        // Draw header line
        doc.moveTo(startX, y - 5)
          .lineTo(startX + colWidths.reduce((a, b) => a + b, 0), y - 5)
          .strokeColor('#ccc')
          .stroke();

        // Table rows
        doc.font('Helvetica').fontSize(8).fillColor('#333');
        tradeTasks.forEach((task) => {
          if (y > 750) {
            doc.addPage();
            y = 50;
          }

          const assignee = task.assignee_first_name
            ? `${task.assignee_first_name} ${task.assignee_last_name}`
            : task.assigned_to_contractor_email || '—';

          const row = [
            String(task.task_number),
            task.title.length > 35 ? task.title.substring(0, 35) + '...' : task.title,
            task.status,
            task.priority,
            assignee.length > 25 ? assignee.substring(0, 25) + '...' : assignee,
          ];

          drawTableRow(doc, row, startX, y, colWidths);
          y += 18;
        });
      }

      // ── Summary page ────────────────────────────────────────
      doc.addPage();
      doc.fontSize(18).font('Helvetica-Bold').fillColor('#333')
        .text('Summary', { align: 'center' });
      doc.moveDown(1);

      const total = data.tasks.length;
      const open = data.tasks.filter((t) => t.status === 'open').length;
      const inProgress = data.tasks.filter((t) => t.status === 'in_progress').length;
      const completed = data.tasks.filter((t) => t.status === 'completed').length;
      const verified = data.tasks.filter((t) => t.status === 'verified').length;

      doc.fontSize(14).font('Helvetica');
      const stats = [
        { label: 'Total Tasks', value: total },
        { label: 'Open', value: open },
        { label: 'In Progress', value: inProgress },
        { label: 'Completed', value: completed },
        { label: 'Verified', value: verified },
      ];

      stats.forEach(({ label, value }) => {
        doc.text(`${label}: ${value}`, { indent: 50 });
        doc.moveDown(0.3);
      });

      if (total > 0) {
        const completionRate = Math.round(((completed + verified) / total) * 100);
        doc.moveDown(1);
        doc.fontSize(16).font('Helvetica-Bold')
          .text(`Completion Rate: ${completionRate}%`, { align: 'center' });
      }

      doc.end();
    } catch (err) {
      reject(err);
    }
  });
}

function groupByTrade(tasks: TaskWithCounts[]): Record<string, TaskWithCounts[]> {
  const groups: Record<string, TaskWithCounts[]> = {};
  for (const task of tasks) {
    const trade = task.trade || 'Unspecified';
    if (!groups[trade]) groups[trade] = [];
    groups[trade].push(task);
  }
  return groups;
}

function drawTableRow(
  doc: PDFKit.PDFDocument,
  cells: string[],
  startX: number,
  y: number,
  colWidths: number[],
): void {
  let x = startX;
  cells.forEach((cell, i) => {
    doc.text(cell, x, y, { width: colWidths[i], lineBreak: false });
    x += colWidths[i];
  });
}
